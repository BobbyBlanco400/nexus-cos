#!/bin/bash
# ==============================================================================
# Nexus COS - PF Fix Nginx Headers & Redirect
# ==============================================================================
# Purpose: Fix Nginx security headers and HTTP→HTTPS redirect configuration
# Target: Works with last 3 PF deployments
# Usage: sudo bash scripts/pf-fix-nginx-headers-redirect.sh
#        sudo DOMAIN=yourdomain.com bash scripts/pf-fix-nginx-headers-redirect.sh
# ==============================================================================

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m' # No Color

# Configuration
DOMAIN="${DOMAIN:-nexuscos.online}"
NGINX_CONF_DIR="/etc/nginx"
NGINX_MAIN_CONF="${NGINX_CONF_DIR}/nginx.conf"
SECURITY_HEADERS_CONF="${NGINX_CONF_DIR}/conf.d/zz-security-headers.conf"

# ==============================================================================
# Utility Functions
# ==============================================================================

print_header() {
    echo ""
    echo -e "${CYAN}╔════════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${CYAN}║                                                                ║${NC}"
    echo -e "${CYAN}║       NEXUS COS - PF FIX NGINX HEADERS & REDIRECT              ║${NC}"
    echo -e "${CYAN}║                                                                ║${NC}"
    echo -e "${CYAN}╚════════════════════════════════════════════════════════════════╝${NC}"
    echo ""
}

print_section() {
    echo ""
    echo -e "${BLUE}═══════════════════════════════════════════════════════════════${NC}"
    echo -e "${BLUE}  $1${NC}"
    echo -e "${BLUE}═══════════════════════════════════════════════════════════════${NC}"
    echo ""
}

print_step() {
    echo -e "${YELLOW}▶${NC} $1"
}

print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

print_error() {
    echo -e "${RED}✗${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

print_info() {
    echo -e "${CYAN}ℹ${NC} $1"
}

# ==============================================================================
# 1. Verify Root Privileges
# ==============================================================================

verify_root() {
    print_section "1. VERIFY ROOT PRIVILEGES"
    
    if [[ $EUID -ne 0 ]]; then
        print_error "This script must be run as root or with sudo"
        echo -e "${YELLOW}Usage:${NC} sudo bash scripts/pf-fix-nginx-headers-redirect.sh"
        exit 1
    fi
    
    print_success "Running with root privileges"
    print_info "Target domain: ${DOMAIN}"
}

# ==============================================================================
# 2. Create Security Headers Configuration
# ==============================================================================

create_security_headers() {
    print_section "2. CREATE SECURITY HEADERS CONFIGURATION"
    
    print_step "Creating conf.d directory if needed..."
    mkdir -p "${NGINX_CONF_DIR}/conf.d"
    print_success "conf.d directory ready"
    
    print_step "Writing security headers to ${SECURITY_HEADERS_CONF}..."
    
    cat > "${SECURITY_HEADERS_CONF}" << 'EOF'
# Nexus COS Security Headers
# Generated by pf-fix-nginx-headers-redirect.sh

# HSTS (HTTP Strict Transport Security)
# Force browsers to use HTTPS for 1 year
add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;

# Content Security Policy
# Configured for nexuscos.online with specific source allowances
add_header Content-Security-Policy "default-src 'self' https://nexuscos.online; img-src 'self' data: blob: https://nexuscos.online; script-src 'self' 'unsafe-inline' https://nexuscos.online; style-src 'self' 'unsafe-inline' https://nexuscos.online; connect-src 'self' https://nexuscos.online https://nexuscos.online/streaming wss://nexuscos.online ws://nexuscos.online;" always;

# X-Content-Type-Options
# Prevent MIME type sniffing
add_header X-Content-Type-Options "nosniff" always;

# X-Frame-Options
# Prevent clickjacking attacks
add_header X-Frame-Options "SAMEORIGIN" always;

# Referrer-Policy
# Control referrer information sent with requests
add_header Referrer-Policy "no-referrer-when-downgrade" always;

# X-XSS-Protection (Legacy, but some browsers still use it)
add_header X-XSS-Protection "1; mode=block" always;
EOF
    
    print_success "Security headers written to ${SECURITY_HEADERS_CONF}"
}

# ==============================================================================
# 3. Ensure conf.d/*.conf Inclusion in nginx.conf
# ==============================================================================

ensure_confd_inclusion() {
    print_section "3. ENSURE CONF.D INCLUSION IN NGINX.CONF"
    
    print_step "Checking if conf.d/*.conf is included in nginx.conf..."
    
    if grep -q "include[[:space:]]*${NGINX_CONF_DIR}/conf.d/.*\.conf" "${NGINX_MAIN_CONF}"; then
        print_success "conf.d/*.conf inclusion already present"
        return 0
    fi
    
    print_warning "conf.d/*.conf inclusion not found, adding it..."
    
    # Backup nginx.conf
    BACKUP_TIMESTAMP=$(date +%Y%m%d_%H%M%S)
    cp "${NGINX_MAIN_CONF}" "${NGINX_MAIN_CONF}.backup.${BACKUP_TIMESTAMP}"
    print_info "Backup created: ${NGINX_MAIN_CONF}.backup.${BACKUP_TIMESTAMP}"
    
    # Find the http block and add the include directive
    # We'll add it right after the opening of the http block
    if grep -q "^http[[:space:]]*{" "${NGINX_MAIN_CONF}"; then
        # Add include directive after http { line
        sed -i '/^http[[:space:]]*{/a \    include '"${NGINX_CONF_DIR}"'/conf.d/*.conf;' "${NGINX_MAIN_CONF}"
        print_success "Added conf.d/*.conf inclusion to nginx.conf"
    else
        print_error "Could not find 'http {' block in nginx.conf"
        print_warning "Please manually add: include ${NGINX_CONF_DIR}/conf.d/*.conf; inside the http block"
    fi
}

# ==============================================================================
# 4. Fix HTTP→HTTPS Redirect in All Vhosts
# ==============================================================================

fix_https_redirect() {
    print_section "4. FIX HTTP→HTTPS REDIRECT IN ALL VHOSTS"
    
    print_step "Fixing redirect patterns in all vhosts..."
    
    local VHOST_COUNT=0
    
    # Process all vhosts in /etc/nginx and /var/www/vhosts/system
    for ROOT in /etc/nginx /var/www/vhosts/system; do
        [ -d "$ROOT" ] || continue
        
        # Find all vhost files containing the domain
        while IFS= read -r VF; do
            [ -f "$VF" ] || continue
            
            # Backup the vhost file
            BACKUP_TIMESTAMP=$(date +%Y%m%d_%H%M%S)
            cp "${VF}" "${VF}.backup.${BACKUP_TIMESTAMP}" 2>/dev/null || true
            
            # Normalize redirect patterns for apex+www
            # Pattern 1: return 301 https://$server_name$request_uri;
            # Pattern 2: return 301 https://domain.com$request_uri; (hardcoded domain)
            # Pattern 3: return 301 https://;
            # All become: return 301 https://$host$request_uri;
            sed -i "s|return[[:space:]]*301[[:space:]]*https://\$server_name\$request_uri;|return 301 https://\$host\$request_uri;|g" "$VF"
            sed -i "s|return[[:space:]]*301[[:space:]]*https://[a-zA-Z0-9.-]*\$request_uri;|return 301 https://\$host\$request_uri;|g" "$VF"
            sed -i "s|return[[:space:]]*301[[:space:]]*https://;|return 301 https://\$host\$request_uri;|g" "$VF"
            
            # Remove any CSP add_header from vhosts so only zz-security-headers.conf applies
            sed -i "/add_header[[:space:]]\+Content-Security-Policy/d" "$VF"
            
            ((VHOST_COUNT++))
            print_info "Processed: ${VF}"
        done < <(grep -RIl --include="*.conf" -E "server_name.*($DOMAIN|www\.$DOMAIN)" "$ROOT" 2>/dev/null || true)
    done
    
    if [[ $VHOST_COUNT -eq 0 ]]; then
        print_warning "No vhost files found for domain: ${DOMAIN}"
    else
        print_success "Fixed redirect patterns in ${VHOST_COUNT} vhost file(s)"
    fi
}

# ==============================================================================
# 5. Remove Stray Backticks
# ==============================================================================

remove_stray_backticks() {
    print_section "5. REMOVE STRAY BACKTICKS FROM NGINX CONFIGS"
    
    print_step "Scanning for backticks in Nginx configuration files..."
    
    local FILES_CLEANED=0
    
    # Strip any stray backticks from all confs in /etc/nginx and /var/www/vhosts/system
    for ROOT in /etc/nginx /var/www/vhosts/system; do
        [ -d "$ROOT" ] || continue
        
        print_info "Processing directory: ${ROOT}"
        
        # Use perl to remove all backticks (ASCII 0x60)
        if command -v perl &> /dev/null; then
            # Find and process all .conf files
            while IFS= read -r conf_file; do
                [ -f "$conf_file" ] || continue
                
                # Check if file contains backticks before processing
                if grep -q '`' "$conf_file" 2>/dev/null; then
                    print_warning "Found backticks in: ${conf_file}"
                    
                    # Backup before modification
                    cp "${conf_file}" "${conf_file}.backup.$(date +%Y%m%d_%H%M%S)" 2>/dev/null || true
                    
                    # Remove backticks using perl
                    perl -0777 -pe 's/\x60//g' -i "$conf_file"
                    
                    ((FILES_CLEANED++))
                    print_success "Cleaned backticks from: ${conf_file}"
                fi
            done < <(find "$ROOT" -type f -name "*.conf" 2>/dev/null || true)
        else
            print_warning "perl not found, using sed fallback"
            # Fallback to sed if perl is not available
            while IFS= read -r conf_file; do
                [ -f "$conf_file" ] || continue
                
                if grep -q '`' "$conf_file" 2>/dev/null; then
                    cp "${conf_file}" "${conf_file}.backup.$(date +%Y%m%d_%H%M%S)" 2>/dev/null || true
                    sed -i 's/`//g' "$conf_file"
                    ((FILES_CLEANED++))
                fi
            done < <(find "$ROOT" -type f -name "*.conf" 2>/dev/null || true)
        fi
    done
    
    if [[ $FILES_CLEANED -eq 0 ]]; then
        print_success "No stray backticks found"
    else
        print_success "Cleaned backticks from ${FILES_CLEANED} file(s)"
    fi
}

# ==============================================================================
# 6. Remove Duplicate Configuration Files
# ==============================================================================

remove_duplicate_configs() {
    print_section "6. REMOVE DUPLICATE CONFIGURATION FILES"
    
    print_step "Checking for Plesk vhost configuration..."
    
    # Check if Plesk vhost exists
    PLESK_VHOST_EXISTS=false
    if ls /var/www/vhosts/system/"${DOMAIN}"/conf/vhost_nginx.conf >/dev/null 2>&1 || \
       ls /var/www/vhosts/system/"${DOMAIN}"/conf/nginx.conf >/dev/null 2>&1; then
        PLESK_VHOST_EXISTS=true
        print_success "Plesk vhost found for ${DOMAIN}"
    else
        print_info "No Plesk vhost found for ${DOMAIN}"
    fi
    
    # If Plesk vhost exists, remove our redirect file to avoid duplicate server_name warnings
    if [[ "$PLESK_VHOST_EXISTS" = true ]]; then
        if [[ -f "${NGINX_CONF_DIR}/conf.d/zz-redirect.conf" ]]; then
            print_step "Removing zz-redirect.conf (Plesk vhost handles redirects)..."
            rm -f "${NGINX_CONF_DIR}/conf.d/zz-redirect.conf"
            print_success "Removed zz-redirect.conf"
        else
            print_info "zz-redirect.conf not found (already removed)"
        fi
    fi
    
    # Remove known duplicate gateway confs
    print_step "Removing duplicate gateway configurations..."
    local REMOVED_COUNT=0
    
    for gateway_conf in \
        "${NGINX_CONF_DIR}/conf.d/pf_gateway_${DOMAIN}.conf" \
        "${NGINX_CONF_DIR}/conf.d/pf_gateway_www.${DOMAIN}.conf"; do
        
        if [[ -f "$gateway_conf" ]]; then
            rm -f "$gateway_conf"
            print_success "Removed: $(basename "$gateway_conf")"
            ((REMOVED_COUNT++))
        fi
    done
    
    if [[ $REMOVED_COUNT -eq 0 ]]; then
        print_info "No duplicate gateway configs found"
    else
        print_success "Removed ${REMOVED_COUNT} duplicate gateway config(s)"
    fi
}

# ==============================================================================
# 7. Validate and Reload Nginx
# ==============================================================================

validate_and_reload_nginx() {
    print_section "7. VALIDATE AND RELOAD NGINX"
    
    print_step "Testing Nginx configuration..."
    
    if nginx -t 2>&1 | grep -q "syntax is ok"; then
        print_success "Nginx configuration is valid"
    else
        print_error "Nginx configuration has errors:"
        nginx -t
        return 1
    fi
    
    print_step "Reloading Nginx..."
    
    if systemctl reload nginx 2>/dev/null || service nginx reload 2>/dev/null; then
        print_success "Nginx reloaded successfully"
    else
        print_error "Failed to reload Nginx"
        return 1
    fi
    
    # Give Nginx a moment to fully reload
    sleep 2
    
    print_success "Nginx is running with new configuration"
}

# ==============================================================================
# 8. Verify Results
# ==============================================================================

verify_results() {
    print_section "8. VERIFY RESULTS"
    
    print_step "Checking HTTP→HTTPS redirect..."
    
    # Test HTTP redirect (if curl is available)
    if command -v curl &> /dev/null; then
        REDIRECT_TEST=$(curl -s -I "http://${DOMAIN}/" 2>/dev/null | tr -d '\r' | grep -i "^location:" | head -1)
        
        if echo "$REDIRECT_TEST" | grep -q "https://${DOMAIN}"; then
            print_success "HTTP redirects correctly to HTTPS"
            print_info "Redirect: ${REDIRECT_TEST}"
            
            # Check for backticks in Location header
            if echo "$REDIRECT_TEST" | grep -q '`'; then
                print_error "Location header contains backticks!"
            else
                print_success "Location header is clean (no backticks)"
            fi
        else
            print_warning "Could not verify redirect (this may be normal if testing locally)"
            print_info "Expected: Location: https://${DOMAIN}/"
        fi
    else
        print_warning "curl not found, skipping redirect check"
    fi
    
    print_step "Checking security headers..."
    
    # Test security headers (if curl is available)
    if command -v curl &> /dev/null; then
        HEADERS=$(curl -s -I -k "https://${DOMAIN}/" 2>/dev/null | tr -d '\r' || curl -s -I "http://localhost/" 2>/dev/null | tr -d '\r')
        
        # Check for each security header
        if echo "$HEADERS" | grep -qi "^Strict-Transport-Security"; then
            HSTS_LINE=$(echo "$HEADERS" | grep -i "^Strict-Transport-Security" | head -1)
            print_success "HSTS header present"
            print_info "${HSTS_LINE}"
            
            # Check for backticks
            if echo "$HSTS_LINE" | grep -q '`'; then
                print_error "HSTS header contains backticks!"
            fi
        else
            print_warning "HSTS header not detected"
        fi
        
        if echo "$HEADERS" | grep -qi "^Content-Security-Policy"; then
            CSP_LINE=$(echo "$HEADERS" | grep -i "^Content-Security-Policy" | head -1)
            print_success "CSP header present"
            print_info "${CSP_LINE}"
            
            # Check for backticks
            if echo "$CSP_LINE" | grep -q '`'; then
                print_error "CSP header contains backticks!"
            else
                print_success "CSP header is clean (no backticks)"
            fi
        else
            print_warning "CSP header not detected"
        fi
        
        if echo "$HEADERS" | grep -qi "^X-Content-Type-Options"; then
            print_success "X-Content-Type-Options header present"
        else
            print_warning "X-Content-Type-Options header not detected"
        fi
        
        if echo "$HEADERS" | grep -qi "^X-Frame-Options"; then
            print_success "X-Frame-Options header present"
        else
            print_warning "X-Frame-Options header not detected"
        fi
        
        if echo "$HEADERS" | grep -qi "^Referrer-Policy"; then
            print_success "Referrer-Policy header present"
        else
            print_warning "Referrer-Policy header not detected"
        fi
    else
        print_warning "curl not found, skipping header checks"
    fi
    
    print_step "Configuration files created/modified:"
    print_info "Security headers: ${SECURITY_HEADERS_CONF}"
}

# ==============================================================================
# Main Execution
# ==============================================================================

main() {
    print_header
    
    # Execute all steps
    verify_root
    create_security_headers
    ensure_confd_inclusion
    fix_https_redirect
    remove_stray_backticks
    remove_duplicate_configs
    validate_and_reload_nginx
    verify_results
    
    # Final summary
    print_section "✅ SETUP COMPLETE"
    echo ""
    echo -e "${GREEN}Nginx security headers and redirect have been configured!${NC}"
    echo ""
    echo -e "${CYAN}What was done:${NC}"
    echo -e "  ${GREEN}✓${NC} Security headers added to ${SECURITY_HEADERS_CONF}"
    echo -e "  ${GREEN}✓${NC} conf.d/*.conf inclusion verified in nginx.conf"
    echo -e "  ${GREEN}✓${NC} conf.d/*.conf inclusion verified in nginx.conf"
    echo -e "  ${GREEN}✓${NC} HTTP→HTTPS redirect fixed in all vhosts to https://\$host\$request_uri"
    echo -e "  ${GREEN}✓${NC} Duplicate CSP headers removed from vhosts"
    echo -e "  ${GREEN}✓${NC} Stray backticks removed from all configs"
    echo -e "  ${GREEN}✓${NC} Duplicate gateway and redirect configs removed"
    echo -e "  ${GREEN}✓${NC} Nginx validated and reloaded"
    echo ""
    echo -e "${CYAN}Next steps:${NC}"
    echo -e "  1. Test your site: ${BLUE}https://${DOMAIN}/${NC}"
    echo -e "  2. Verify headers: ${BLUE}curl -I https://${DOMAIN}/${NC}"
    echo -e "  3. Check redirect: ${BLUE}curl -I http://${DOMAIN}/${NC}"
    echo ""
}

# Run main function
main "$@"
